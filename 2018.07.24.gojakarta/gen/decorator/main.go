package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"html/template"
	"io/ioutil"
	"os"
)

// MAIN OMIT

func main() {
	// Parse source code
	node, err := ParseFile(os.Getenv("GOFILE"))
	if err != nil { //OMIT
		panic(err) //OMIT
	} //OMIT
	ts := GetDesiredNode(node, os.Args[1])

	// Extract useful data
	id, err := ExtractData(ts)
	if err != nil { //OMIT
		panic(err) //OMIT
	} //OMIT
	id.Package = os.Getenv("GOPACKAGE")

	// Generate output using extracted data with template's help
	var buff bytes.Buffer
	t := template.Must(template.New("tmpl").Parse(tmpl))
	err = t.Execute(&buff, id)
	if err != nil { //OMIT
		panic(err) //OMIT
	} //OMIT

	// Prettify output
	res, err := format.Source(buff.Bytes())
	if err != nil { //OMIT
		panic(err) //OMIT
	} //OMIT

	// Write into file
	err = ioutil.WriteFile("dec_"+os.Getenv("GOFILE"), res, 0644)
	if err != nil { //OMIT
		panic(err) //OMIT
	} //OMIT
}

// MAIN OMIT
// PARSEFILE OMIT

func ParseFile(filename string) (*ast.File, error) {
	fs := token.NewFileSet()
	return parser.ParseFile(fs, filename, nil, 0)
}

// PARSEFILE OMIT

func GetDesiredNode(node *ast.File, name string) *ast.TypeSpec {
	selector := func(n ast.Node) bool {
		typespec, ok := n.(*ast.TypeSpec)
		if !ok {
			return false
		}

		return typespec.Name.Name == name
	}

	nf := &NodeFinder{Selector: selector}
	ast.Walk(nf, node)

	if ts, ok := nf.Res.(*ast.TypeSpec); ok {
		return ts
	} else {
		return nil
	}
}

func ExtractData(node *ast.TypeSpec) (InterfaceDefinition, error) {
	id := InterfaceDefinition{Name: node.Name.Name}
	intf, ok := node.Type.(*ast.InterfaceType)
	if !ok {
		return id, fmt.Errorf("%v is not interface", node.Name)
	}

	for _, v := range intf.Methods.List {
		fn, ok := v.Type.(*ast.FuncType)
		if !ok {
			continue
		}

		m := Method{
			Name: v.Names[0].Name,
			Args: GetName(fn.Params),
			Rets: GetName(fn.Results),
		}
		id.Methods = append(id.Methods, m)
	}

	return id, nil
}

func GetName(fl *ast.FieldList) []string {
	var res []string

	for _, f := range fl.List {
		ident, ok := f.Type.(*ast.Ident)
		if !ok {
			continue
		}

		var name string
		if ident.Obj == nil {
			name = ident.Name
		} else {
			name = ident.Obj.Name
		}
		res = append(res, name)
	}

	return res
}

// STRUCTDATA OMIT

type InterfaceDefinition struct {
	Package string
	Name    string
	Methods []Method
}

type Method struct {
	Name string
	Args []string
	Rets []string
}

// STRUCTDATA OMIT

type NodeFinder struct {
	Res      ast.Node
	Selector func(n ast.Node) bool
}

func (nf *NodeFinder) Visit(node ast.Node) ast.Visitor {
	if node == nil {
		return nf
	}

	if nf.Selector(node) {
		nf.Res = node
		return nil
	}

	return nf
}

// TEMPLATE OMIT

const tmpl = `
// Code generated by "decorator {{.Name}}"; DO NOT EDIT.

package {{.Package}}

import "fmt"

type {{.Name}}Log struct {
	Origin {{.Name}}
}

{{$type := .Name}}
{{range .Methods}}
func (d *{{$type}}Log) {{.Name}}(
	{{- range $i, $v := .Args}}p{{$i}} {{$v}},{{end}}) (
	{{- range .Rets}}{{.}},{{end}}) {
	defer fmt.Println("{{.Name}} is called")
	return d.Origin.{{.Name}}({{range $i, $v := .Args}}p{{$i}},{{end}})
}
{{end}}
`

// TEMPLATE OMIT
